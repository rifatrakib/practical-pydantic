## Schema

_Pydantic_ allows auto creation of JSON Schemas from models.

The generated schemas are compliant with the specifications: `JSON Schema Core`, `JSON Schema Validation` and `OpenAPI`.

`BaseModel.schema` will return a dict of the schema, while `BaseModel.schema_json` will return a JSON string representation of that dict.

Sub-models used are added to the `definitions` JSON attribute and referenced, as per the spec.

All sub-models' (and their sub-models') schemas are put directly in a top-level `definitions` JSON key for easy re-use and reference.

"Sub-models" with modifications (via the `Field` class) like a custom title, description or default value, are recursively included instead of referenced.

The `description` for models is taken from either the docstring of the class or the argument `description` to the `Field` class.

The schema is generated by default using aliases as keys, but it can be generated using model property names instead by calling `MainModel.schema/schema_json(by_alias=False)`.

The format of `$ref`s (`"#/definitions/FooBar"` above) can be altered by calling `schema()` or `schema_json()` with the `ref_template` keyword argument, e.g. `ApplePie.schema(ref_template='/schemas/{model}.json#/')`, here `{model}` will be replaced with the model naming using `str.format()`.


#### Getting schema of a specified type

_Pydantic_ includes two standalone utility functions `schema_of` and `schema_json_of` that can be used to apply the schema generation logic used for pydantic models in a more ad-hoc way. These functions behave similarly to `BaseModel.schema` and `BaseModel.schema_json`, but work with arbitrary pydantic-compatible types.


#### Field customization

Optionally, the `Field` function can be used to provide extra information about the field and validations. It has the following arguments.

* `default`: (a positional argument) the default value of the field. Since the `Field` replaces the field's default, this first argument can be used to set the default. Use ellipsis (`...`) to indicate the field is required.

* `default_factory`: a zero-argument callable that will be called when a default value is needed for this field. Among other purposes, this can be used to set dynamic default values. It is forbidden to set both `default` and `default_factory`.

* `alias`: the public name of the field.

* `title`: if omitted, `field_name.title()` is used.

* `description`: if omitted and the annotation is a sub-model, the docstring of the sub-model will be used.

* `exclude`: exclude this field when dumping (`.dict` and `.json`) the instance. The exact syntax and configuration options are described in details in the `exporting models section`.

* `include`: include (only) this field when dumping (`.dict` and `.json`) the instance. The exact syntax and configuration options are described in details in the `exporting models section`.

* `const`: this argument must be the same as the field's default value if present.

* `gt`: for numeric values (`int`, `float`, `Decimal`), adds a validation of "greater than" and an annotation of `exclusiveMinimum` to the JSON Schema.

* `ge`: for numeric values, this adds a validation of "greater than or equal" and an annotation of `minimum` to the JSON Schema.

* `lt`: for numeric values, this adds a validation of "less than" and an annotation of `exclusiveMaximum` to the JSON Schema.

* `le`: for numeric values, this adds a validation of "less than or equal" and an annotation of `maximum` to the JSON Schema.

* `multiple_of`: for numeric values, this adds a validation of "a multiple of" and an annotation of multipleOf to the JSON Schema.

* `max_digits`: for `Decimal` values, this adds a validation to have a maximum number of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes.

* `decimal_places`: for `Decimal` values, this adds a validation to have at most a number of decimal places allowed. It does not include trailing decimal zeroes.

* `min_items`: for list values, this adds a corresponding validation and an annotation of `minItems` to the JSON Schema.

* `max_items`: for list values, this adds a corresponding validation and an annotation of `maxItems` to the JSON Schema.

* `unique_items`: for list values, this adds a corresponding validation and an annotation of `uniqueItems` to the JSON Schema.

* `min_length`: for string values, this adds a corresponding validation and an annotation of `minLength` to the JSON Schema.

* `max_length`: for string values, this adds a corresponding validation and an annotation of `maxLength` to the JSON Schema.

* `allow_mutation`: a boolean which defaults to `True`. When False, the field raises a `TypeError` if the field is assigned on an instance. The model config must set `validate_assignment` to `True` for this check to be performed.

* `regex`: for string values, this adds a Regular Expression validation generated from the passed string and an annotation of `pattern` to the JSON Schema.

> _pydantic_ validates strings using `re.match`, which treats regular expressions as implicitly anchored at the beginning. On the contrary, JSON Schema validators treat the `pattern` keyword as implicitly unanchored, more like what `re.search` does.
>
> For interoperability, depending on your desired behavior, either explicitly anchor your regular expressions with `^` (e.g. `^foo` to match any string starting with `foo`), or explicitly allow an arbitrary prefix with `.*?` (e.g. `.*?foo` to match any string containing the substring `foo`).

* `repr`: a boolean which defaults to `True`. When False, the field shall be hidden from the object representation.

* `**` any other keyword arguments (e.g. examples) will be added verbatim to the field's schema.

Instead of using `Field`, the `fields` property of `the Config class` can be used to set all of the arguments above except `default`.


##### Unenforced Field constraints

If _pydantic_ finds constraints which are not being enforced, an error will be raised. If you want to force the constraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments to `Field()` with the raw schema attribute name.


##### typing.Annotated Fields

Rather than assigning a `Field` value, it can be specified in the type hint with `typing.Annotated`.

`Field` can only be supplied once per field - an error will be raised if used in `Annotated` and as the assigned value. Defaults can be set outside `Annotated` as the assigned value or with `Field.default_factory` inside `Annotated` - the `Field.default` argument is not supported inside `Annotated`.

For versions of Python prior to 3.9, `typing_extensions.Annotated` can be used.


#### Modifying schema in custom fields

Custom field types can customise the schema generated for them using the `__modify_schema__` class method.

`__modify_schema__` can also take a `field` argument which will have type `Optional[ModelField]`. _pydantic_ will inspect the signature of `__modify_schema__` to determine whether the `field` argument should be included.


#### JSON Schema Types

Types, custom field types, and constraints (like `max_length`) are mapped to the corresponding spec formats in the following priority order (when there is an equivalent available):

1. JSON Schema Core
2. JSON Schema Validation
3. OpenAPI Data Types
4. The standard `format` JSON field is used to define pydantic extensions for more complex `string` sub-types.

The field schema mapping from Python / pydantic to JSON Schema is done as follows:

<table style="width:100%"><thead><tr><th>Python type</th><th>JSON Schema Type</th><th>Additional JSON Schema</th><th>Defined in</th></tr></thead><tbody><tr><td><code>None</code></td><td><code>null</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Same for <code>type(None)</code> or <code>Literal[None]</code></em></td></tr><tr><td><code>bool</code></td><td><code>boolean</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>str</code></td><td><code>string</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>float</code></td><td><code>number</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>int</code></td><td><code>integer</code></td><td></td><td>JSON Schema Validation</td></tr><tr><td><code>dict</code></td><td><code>object</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>list</code></td><td><code>array</code></td><td><code>{"items": {}}</code></td><td>JSON Schema Core</td></tr><tr><td><code>tuple</code></td><td><code>array</code></td><td><code>{"items": {}}</code></td><td>JSON Schema Core</td></tr><tr><td><code>set</code></td><td><code>array</code></td><td><code>{"items": {}, "uniqueItems": true}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>frozenset</code></td><td><code>array</code></td><td><code>{"items": {}, "uniqueItems": true}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>List[str]</code></td><td><code>array</code></td><td><code>{"items": {"type": "string"}}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>And equivalently for any other sub type, e.g. <code>List[int]</code>.</em></td></tr><tr><td><code>Tuple[str, ...]</code></td><td><code>array</code></td><td><code>{"items": {"type": "string"}}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>And equivalently for any other sub type, e.g. <code>Tuple[int, ...]</code>.</em></td></tr><tr><td><code>Tuple[str, int]</code></td><td><code>array</code></td><td><code>{"items": [{"type": "string"}, {"type": "integer"}], "minItems": 2, "maxItems": 2}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>And equivalently for any other set of subtypes. Note: If using schemas for OpenAPI, you shouldn'tuse this declaration, as it would not be valid in OpenAPI (although it is valid in JSONSchema).</em></td></tr><tr><td><code>Dict[str, int]</code></td><td><code>object</code></td><td><code>{"additionalProperties": {"type": "integer"}}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>And equivalently for any other subfields for dicts. Have in mind that although you can use othertypes as keys for dicts with Pydantic, only strings are valid keys for JSON, and so, only str isvalid as JSON Schema key types.</em></td></tr><tr><td><code>Union[str, int]</code></td><td><code>anyOf</code></td><td><code>{"anyOf": [{"type": "string"}, {"type": "integer"}]}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>And equivalently for any other subfields for unions.</em></td></tr><tr><td><code>Enum</code></td><td><code>enum</code></td><td><code>{"enum": [...]}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>All the literal values in the enum are included in the definition.</em></td></tr><tr><td><code>SecretStr</code></td><td><code>string</code></td><td><code>{"writeOnly": true}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>SecretBytes</code></td><td><code>string</code></td><td><code>{"writeOnly": true}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>EmailStr</code></td><td><code>string</code></td><td><code>{"format": "email"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NameEmail</code></td><td><code>string</code></td><td><code>{"format": "name-email"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>AnyUrl</code></td><td><code>string</code></td><td><code>{"format": "uri"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>Pattern</code></td><td><code>string</code></td><td><code>{"format": "regex"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>bytes</code></td><td><code>string</code></td><td><code>{"format": "binary"}</code></td><td>OpenAPI</td></tr><tr><td><code>Decimal</code></td><td><code>number</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>UUID1</code></td><td><code>string</code></td><td><code>{"format": "uuid1"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>UUID3</code></td><td><code>string</code></td><td><code>{"format": "uuid3"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>UUID4</code></td><td><code>string</code></td><td><code>{"format": "uuid4"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>UUID5</code></td><td><code>string</code></td><td><code>{"format": "uuid5"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>UUID</code></td><td><code>string</code></td><td><code>{"format": "uuid"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Suggested in OpenAPI.</em></td></tr><tr><td><code>FilePath</code></td><td><code>string</code></td><td><code>{"format": "file-path"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>DirectoryPath</code></td><td><code>string</code></td><td><code>{"format": "directory-path"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>Path</code></td><td><code>string</code></td><td><code>{"format": "path"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>datetime</code></td><td><code>string</code></td><td><code>{"format": "date-time"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>date</code></td><td><code>string</code></td><td><code>{"format": "date"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>time</code></td><td><code>string</code></td><td><code>{"format": "time"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>timedelta</code></td><td><code>number</code></td><td><code>{"format": "time-delta"}</code></td><td>Difference in seconds (a <code>float</code>), with Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Suggested in JSON Schema repository's issues by maintainer.</em></td></tr><tr><td><code>Json</code></td><td><code>string</code></td><td><code>{"format": "json-string"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td><code>IPv4Address</code></td><td><code>string</code></td><td><code>{"format": "ipv4"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>IPv6Address</code></td><td><code>string</code></td><td><code>{"format": "ipv6"}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>IPvAnyAddress</code></td><td><code>string</code></td><td><code>{"format": "ipvanyaddress"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv4 or IPv6 address as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPv4Interface</code></td><td><code>string</code></td><td><code>{"format": "ipv4interface"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv4 interface as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPv6Interface</code></td><td><code>string</code></td><td><code>{"format": "ipv6interface"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv6 interface as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPvAnyInterface</code></td><td><code>string</code></td><td><code>{"format": "ipvanyinterface"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv4 or IPv6 interface as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPv4Network</code></td><td><code>string</code></td><td><code>{"format": "ipv4network"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv4 network as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPv6Network</code></td><td><code>string</code></td><td><code>{"format": "ipv6network"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv6 network as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>IPvAnyNetwork</code></td><td><code>string</code></td><td><code>{"format": "ipvanynetwork"}</code></td><td>Pydantic standard "format" extension</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>IPv4 or IPv6 network as used in <code>ipaddress</code> module</em></td></tr><tr><td><code>StrictBool</code></td><td><code>boolean</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>StrictStr</code></td><td><code>string</code></td><td></td><td>JSON Schema Core</td></tr><tr><td><code>ConstrainedStr</code></td><td><code>string</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>If the type has values declared for the constraints, they are included as validations. See themapping for <code>constr</code> below.</em></td></tr><tr><td><code>constr(regex='^text$', min_length=2, max_length=10)</code></td><td><code>string</code></td><td><code>{"pattern": "^text$", "minLength": 2, "maxLength": 10}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Any argument not passed to the function (not defined) will not be included in the schema.</em></td></tr><tr><td><code>ConstrainedInt</code></td><td><code>integer</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>If the type has values declared for the constraints, they are included as validations. See themapping for <code>conint</code> below.</em></td></tr><tr><td><code>conint(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code></td><td><code>integer</code></td><td><code>{"maximum": 5, "exclusiveMaximum": 6, "minimum": 2, "exclusiveMinimum": 1, "multipleOf": 2}</code></td><td></td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Any argument not passed to the function (not defined) will not be included in the schema.</em></td></tr><tr><td><code>PositiveInt</code></td><td><code>integer</code></td><td><code>{"exclusiveMinimum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NegativeInt</code></td><td><code>integer</code></td><td><code>{"exclusiveMaximum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NonNegativeInt</code></td><td><code>integer</code></td><td><code>{"minimum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NonPositiveInt</code></td><td><code>integer</code></td><td><code>{"maximum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>ConstrainedFloat</code></td><td><code>number</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>If the type has values declared for the constraints, they are included as validations. See themapping for <code>confloat</code> below.</em></td></tr><tr><td><code>confloat(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code></td><td><code>number</code></td><td><code>{"maximum": 5, "exclusiveMaximum": 6, "minimum": 2, "exclusiveMinimum": 1, "multipleOf": 2}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Any argument not passed to the function (not defined) will not be included in the schema.</em></td></tr><tr><td><code>PositiveFloat</code></td><td><code>number</code></td><td><code>{"exclusiveMinimum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NegativeFloat</code></td><td><code>number</code></td><td><code>{"exclusiveMaximum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NonNegativeFloat</code></td><td><code>number</code></td><td><code>{"minimum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>NonPositiveFloat</code></td><td><code>number</code></td><td><code>{"maximum": 0}</code></td><td>JSON Schema Validation</td></tr><tr><td><code>ConstrainedDecimal</code></td><td><code>number</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>If the type has values declared for the constraints, they are included as validations. See themapping for <code>condecimal</code> below.</em></td></tr><tr><td><code>condecimal(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code></td><td><code>number</code></td><td><code>{"maximum": 5, "exclusiveMaximum": 6, "minimum": 2, "exclusiveMinimum": 1, "multipleOf": 2}</code></td><td>JSON Schema Validation</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>Any argument not passed to the function (not defined) will not be included in the schema.</em></td></tr><tr><td><code>BaseModel</code></td><td><code>object</code></td><td></td><td>JSON Schema Core</td></tr><tr><td colspan="4" style="border-top: none; padding-top: 0"><em>All the properties defined will be defined with standard JSON Schema, including submodels.</em></td></tr><tr><td><code>Color</code></td><td><code>string</code></td><td><code>{"format": "color"}</code></td><td>Pydantic standard "format" extension</td></tr></tbody></table>


#### Top-level schema generation

You can also generate a top-level JSON Schema that only includes a list of models and related sub-models in its `definitions`.
